<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 闲散记事]]></title>
  <link href="http://lvzwq.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://lvzwq.github.io/"/>
  <updated>2017-08-17T00:29:18+08:00</updated>
  <id>http://lvzwq.github.io/</id>
  <author>
    <name><![CDATA[Lvzwq]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java内存区域与垃圾收集器]]></title>
    <link href="http://lvzwq.github.io/blog/2017/08/17/javanei-cun-qu-yu-yu-la-ji-shou-ji-qi/"/>
    <updated>2017-08-17T00:11:08+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/08/17/javanei-cun-qu-yu-yu-la-ji-shou-ji-qi</id>
    <content type="html"><![CDATA[<h2>运行程序时数据区域</h2>

<blockquote><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p></blockquote>

<!-- more -->


<p><img src="http://7xig7d.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98.png" alt="http://7xig7d.com1.z0.glb.clouddn.com/%E5%86%85%E5%AD%98.png" /></p>

<h3>程序计数器(Program Counter Register)</h3>

<p>程序计数器是一块较小的内存空间，他可以看做是当前线程所执行的的字节码的行号指示器。</p>

<h3>Java 虚拟机栈</h3>

<p>线程私有，生命周期与线程相同。每一个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。</p>

<h3>本地方法栈</h3>

<p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法(字节码)服务，而本地方法栈则为虚拟机使用的Native方法服务。</p>

<h3>Java堆</h3>

<p>对于大多数应用而言，Java堆是Java虚拟机所管理的内存中最大的一块，在虚拟机启动时创建，是所有线程共享的一块内存区域，此内存区域的作用就是存放对象实例，几乎所有的对象实例都在这里分配内存。Java堆是垃圾回收器管理的主要区域，也被成为GC堆。</p>

<h3>方法区</h3>

<p>方法区是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译的代码等数据。</p>

<h3>运行时常量池(Runtime Constants Pool)</h3>

<p>运行时常量池是方法区的一部分。</p>

<h3>对象创建</h3>

<blockquote><p>虚拟机遇到一条new指令是，首先去检查这个指令额参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有则必须执行相应的类加载过程。
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存空间从Java堆中划分出来。</p></blockquote>

<h3>java堆内存分配方式</h3>

<ul>
<li>指针碰撞：假设java堆中内存是绝对规整的</li>
<li>空闲列表:  虚拟机维护一个列表，记录那些内存块是可用的</li>
</ul>


<p>java堆内存是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。因此在使用Serial、ParNew等带有Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，通常采用空闲列表。</p>

<h2>垃圾收集器与内存分配策略</h2>

<h3>判断对象是否存活</h3>

<ul>
<li><p>引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器值就减1，在任意时刻计数器为0的对象就是不可能再被使用的。目前主流的虚拟机里并没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间循环引用的问题。</p></li>
<li><p>可达性分析算法：通过一系列的称为”GC Roots“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GC Roots没有任何引用链相连时，则称为此对象是不可用的，它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p></li>
</ul>


<p>在JDK1.2后，Java对引用的概念进行了扩充，将引用划分为强引用、软引用、弱引用、虚引用，这4种引用强度逐渐减弱。</p>

<h3>垃圾收集算法</h3>

<ul>
<li><p><strong>标记-清除算法(Mark-Sweep)</strong>： 算法分为标记和清除两个阶段，是最基础的收集算法。首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
主要的不足有两个:
效率问题，标记和清除两个过程的效率都不高；
空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够连续内存而不得不提前出发另一次的垃圾回收动作。</p></li>
<li><p><strong>复制算法</strong>: 为了解决效率问题，将可用内存按容量大小分为大小相同的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配是也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。</p></li>
</ul>


<blockquote><p>商业虚拟机都采用这种收集算法来回收新生代，因为新生代中的对象98%是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Suvivor空间，每次使用Eden空间和其中一块Survivor空间。当回收时，将Eden空间和Survivor空间中还存活的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden空间和Survivor空间。HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1.
当Survivor空间不够用时，需要依赖其他内存(这里指老年代)进行分配担保。</p></blockquote>

<ul>
<li><p><strong>标记-整理算法</strong>： 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更为关键的是，如果不想浪费50%的空间，就需要有额外的空间进行担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用这种算法。
标记整理算法的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向一段移动，然后直接清理掉端边界以外的内存。</p></li>
<li><p><strong>分代收集算法</strong>：根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样可以根据各个年代的特点采用最适合的收集算法。
在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就使用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行收集。</p></li>
</ul>


<h2>垃圾收集器</h2>

<p><img src="http://7xig7d.com1.z0.glb.clouddn.com/%E5%88%86%E5%8C%BA.png" alt="http://7xig7d.com1.z0.glb.clouddn.com/%E5%88%86%E5%8C%BA.png" /></p>

<h3>Serial收集器</h3>

<blockquote><p>Serial收集器是最基本、发展历史最悠久的收集器，是一个单线程的收集器。只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p></blockquote>

<h3>ParNew收集器</h3>

<blockquote><p>ParNew收集器是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为基本与Serial收集器完全一样。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot学习笔记一]]></title>
    <link href="http://lvzwq.github.io/blog/2017/08/17/springboxue-xi-bi-ji-1/"/>
    <updated>2017-08-17T00:09:28+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/08/17/springboxue-xi-bi-ji-1</id>
    <content type="html"><![CDATA[<h2>特点</h2>

<ul>
<li>Create stand-alone Spring applications</li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)</li>
<li>Provide opinionated &lsquo;starter&rsquo; POMs to simplify your Maven configuration</li>
<li>Automatically configure Spring whenever possible</li>
<li>Provide production-ready features such as metrics, health checks and externalized configuration</li>
<li>Absolutely no code generation and no requirement for XML configuration</li>
</ul>


<!-- more -->


<p>SpringBoot应用Maven依赖加入
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;dependency&gt;
</span><span class='line'>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</span><span class='line'>    &lt;artifactId&gt;spring-boot-parent&lt;/artifactId&gt;
</span><span class='line'>    &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;
</span><span class='line'>    &lt;scope&gt;import&lt;/scope&gt;
</span><span class='line'>    &lt;type&gt;pom&lt;/type&gt;
</span><span class='line'>&lt;/dependency&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;dependency&gt;
</span><span class='line'>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
</span><span class='line'>    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
</span><span class='line'>    &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;
</span><span class='line'>&lt;/dependency&gt;</span></code></pre></td></tr></table></div></figure></p>

<p>如果要web环境，只需要加入web的starter
<code>
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;1.5.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></p>

<p>SpringBoot应用建立
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Slf4j
</span><span class='line'>@SpringBootApplication
</span><span class='line'>public class Application {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
</span><span class='line'>    SpringApplication app = new SpringApplication(Application.class);
</span><span class='line'>    app.run(args);
</span><span class='line'>    //或者直接调用run方法
</span><span class='line'>   //SpringApplication.run(Application.class, args);
</span><span class='line'>}     
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure>
注解@SpringBootApplication是@Configuration、@EnableAutoConfiguration 和@ComponentScan的简化方式。</p>

<h3>初始化</h3>

<p>创建SpringApplication对象实例，构造器中会调用初始化操作
<code>java
@SuppressWarnings({ "unchecked", "rawtypes" })
private void initialize(Object[] sources) {
   if (sources != null &amp;&amp; sources.length &gt; 0) {
      this.sources.addAll(Arrays.asList(sources));
   }
    // 判断是否是web程序(javax.servlet.Servlet和org.springframework.web.context.ConfigurableWebApplicationContext都必须在类加载器中存在)，
    // 并设置到webEnvironment属性中
   this.webEnvironment = deduceWebEnvironment();
   // 从spring.factories文件中找出key为ApplicationContextInitializer的类并实例化后设置到SpringApplication的initializers属性中。
   //这个过程也就是找出所有的应用程序初始化器
   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
    // 从spring.factories文件中找出key为ApplicationListener的类并实例化后设置到SpringApplication的listeners属性中。
    //这个过程就是找出所有的应用程序事件监听器
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   // 找出main类，这里是Application类
   this.mainApplicationClass = deduceMainApplicationClass();
}
</code></p>

<p>判断是否是WEB环境
<code>Java
private boolean deduceWebEnvironment() {
   for (String className : WEB_ENVIRONMENT_CLASSES) {
      if (!ClassUtils.isPresent(className, null)) {
         return false;
      }
   }
   return true;
}
</code></p>

<p>ApplicationContextInitializer，应用程序初始化器，做一些初始化的工作：
<code>Java
public interface ApplicationContextInitializer&lt;C extends ConfigurableApplicationContext&gt; {
    void initialize(C applicationContext);
}
</code></p>

<p>ApplicationListener，应用程序事件(ApplicationEvent)监听器：
<code>java
public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener {
    void onApplicationEvent(E event);
}
</code></p>

<p>应用程序事件(ApplicationEvent)监听器有一下几种:(org.springframework.boot.context.event)
<code>
ApplicationStartingEvent(应用程序启动事件)
ApplicationEnvironmentPreparedEvent(环境准备事件)
ApplicationPreparedEvent(准备事件)
ApplicationReadyEvent(启动事件)
ApplicationFailedEvent(失败事件)
</code></p>

<p>默认情况下，initialize方法从spring.factories文件中找出的key为ApplicationContextInitializer的类有：
<code>
org.springframework.boot.context.config.DelegatingApplicationContextInitializer
org.springframework.boot.context.ContextIdApplicationContextInitializer
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer
org.springframework.boot.context.web.ServerPortInfoApplicationContextInitializer
org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer
</code></p>

<p>key为ApplicationListener的有：
<code>
org.springframework.boot.context.config.AnsiOutputApplicationListener
org.springframework.boot.context.config.ConfigFileApplicationListener
org.springframework.boot.logging.LoggingApplicationListener
org.springframework.boot.logging.ClasspathLoggingApplicationListener
org.springframework.boot.autoconfigure.BackgroundPreinitializer
org.springframework.boot.context.config.DelegatingApplicationListener
org.springframework.boot.builder.ParentContextCloserApplicationListener
org.springframework.boot.context.FileEncodingApplicationListener
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
</code></p>

<p>分析run方法之前，先看一下SpringApplication中的一些事件和监听器概念</p>

<blockquote><p>首先是SpringApplicationRunListeners类和SpringApplicationRunListener类的介绍。</p></blockquote>

<p>SpringApplicationRunListeners内部持有SpringApplicationRunListener集合和1个Log日志类。用于SpringApplicationRunListener监听器的批量执行。</p>

<p>SpringApplicationRunListener看名字也知道用于监听SpringApplication的run方法的执行。</p>

<pre><code>
started(run方法执行的时候立马执行；对应事件的类型是ApplicationStartingEvent)

environmentPrepared(ApplicationContext创建之前并且环境信息准备好的时候调用；对应事件的类型是ApplicationEnvironmentPreparedEvent)

contextPrepared(ApplicationContext创建好并且在source加载之前调用一次；没有具体的对应事件)

contextLoaded(ApplicationContext创建并加载之后并在refresh之前调用；对应事件的类型是ApplicationPreparedEvent)

finished(run方法结束之前调用；对应事件的类型是ApplicationReadyEvent或ApplicationFailedEvent)
</code></pre>

<h3>启动</h3>

<pre><code>/**
 * Run the Spring application, creating and refreshing a new
 * {@link ApplicationContext}.
 * @param args the application arguments (usually passed from a Java main method)
 * @return a running {@link ApplicationContext}
 */
public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch(); // 构造一个任务执行观察器
   stopWatch.start();   // 开始执行，记录开始时间
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   //加载META-INF/spring.factories, 获取SpringApplicationRunListeners，内部只有一个EventPublishingRunListener
   SpringApplicationRunListeners listeners = getRunListeners(args);  
   //这里接受ApplicationStartingEvent事件的listener会执行相应的操作
   listeners.starting();
   try {
      // 构造一个应用程序参数持有类
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
      //创建应用程序的环境信息。如果是web程序，创建StandardServletEnvironment；否则，创建StandardEnvironment
      //执行ApplicationEnvironmentPreparedEvent事件
      ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
      Banner printedBanner = printBanner(environment);
       // 创建Spring容器
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments, printedBanner);
      // Spring容器的刷新
      refreshContext(context);
      //// 调用Spring容器中的ApplicationRunner和CommandLineRunner接口的实现类
      afterRefresh(context, applicationArguments);
      // 广播出ApplicationReadyEvent事件给相应的监听器执行
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
      }
       // 返回Spring容器
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
</code></pre>

<p>创建容器中
Spring 5 - Spring webflux 是一个新的非堵塞函数式 Reactive Web 框架，可以用来建立异步的，非阻塞，事件驱动的服务，并且扩展性非常好</p>

<h3>应用Application启动过程</h3>

<p>创建容器阶段
<code>java
protected ConfigurableApplicationContext createApplicationContext() {
   Class&lt;?&gt; contextClass = this.applicationContextClass;
    //判断是WEB容器还是非WEB容器
   if (contextClass == null) {
      try {
         contextClass = Class.forName(this.webEnvironment
               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               "Unable create a default ApplicationContext, "
                     + "please specify an ApplicationContextClass",
               ex);
      }
   }
   return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);
}
</code></p>

<p>容器准备阶段
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void prepareContext(ConfigurableApplicationContext context,
</span><span class='line'>      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
</span><span class='line'>      ApplicationArguments applicationArguments, Banner printedBanner) {
</span><span class='line'>   // 设置Spring容器的环境信息
</span><span class='line'>   context.setEnvironment(environment);
</span><span class='line'>    // 回调方法，Spring容器创建之后做一些额外的事
</span><span class='line'>   postProcessApplicationContext(context);
</span><span class='line'>   // SpringApplication的的初始化器开始工作,批量执行ApplicationContextInitializer.initialize()方法
</span><span class='line'>   applyInitializers(context);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   listeners.contextPrepared(context);  //没对应具体的事件，EventPublishingRunListener.contextPrepared()不执行任何操作
</span><span class='line'>   if (this.logStartupInfo) {
</span><span class='line'>      logStartupInfo(context.getParent() == null);
</span><span class='line'>      logStartupProfileInfo(context);
</span><span class='line'>   }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   // Add boot specific singleton beans
</span><span class='line'>   context.getBeanFactory().registerSingleton(&ldquo;springApplicationArguments&rdquo;, applicationArguments);
</span><span class='line'>   if (printedBanner != null) {
</span><span class='line'>      context.getBeanFactory().registerSingleton(&ldquo;springBootBanner&rdquo;, printedBanner);
</span><span class='line'>   }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   // Load the sources
</span><span class='line'>   Set&lt;Object&gt; sources = getSources();
</span><span class='line'>   Assert.notEmpty(sources, &ldquo;Sources must not be empty&rdquo;);
</span><span class='line'>   //加载bean到容器context中
</span><span class='line'>   load(context, sources.toArray(new Object[sources.size()]));
</span><span class='line'>   //执行ApplicationPreparedEvent
</span><span class='line'>   listeners.contextLoaded(context);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;其中&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;/&lt;em&gt;*
</span><span class='line'> * Apply any relevant post processing the {@link ApplicationContext}. Subclasses can
</span><span class='line'> * apply additional processing as required.
</span><span class='line'> * @param context the application context
</span><span class='line'> &lt;/em&gt;/
</span><span class='line'>protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
</span><span class='line'>   if (this.beanNameGenerator != null) {
</span><span class='line'>      context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, this.beanNameGenerator);
</span><span class='line'>   }
</span><span class='line'>   // 如果SpringApplication设置了资源加载器，设置到Spring容器中
</span><span class='line'>   if (this.resourceLoader != null) {
</span><span class='line'>      if (context instanceof GenericApplicationContext) {
</span><span class='line'>         ((GenericApplicationContext) context).setResourceLoader(this.resourceLoader);
</span><span class='line'>      }
</span><span class='line'>      if (context instanceof DefaultResourceLoader) {
</span><span class='line'>         ((DefaultResourceLoader) context).setClassLoader(this.resourceLoader.getClassLoader());
</span><span class='line'>      }
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>容器刷新阶段
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>private void refreshContext(ConfigurableApplicationContext context) {
</span><span class='line'>   refresh(context);
</span><span class='line'>   if (this.registerShutdownHook) {
</span><span class='line'>      try {
</span><span class='line'>         context.registerShutdownHook();
</span><span class='line'>      }
</span><span class='line'>      catch (AccessControlException ex) {
</span><span class='line'>         // Not allowed in some environments.
</span><span class='line'>      }
</span><span class='line'>   }
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;执行applicationContext.refresh()方法&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;protected void refresh(ApplicationContext applicationContext) {
</span><span class='line'>   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);
</span><span class='line'>   ((AbstractApplicationContext) applicationContext).refresh();
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h2&gt;spring-context包内的applicationContext.refresh()方法&lt;/h2&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;public void refresh() throws BeansException, IllegalStateException {
</span><span class='line'>    Object var1 = this.startupShutdownMonitor;
</span><span class='line'>    synchronized(this.startupShutdownMonitor) {
</span><span class='line'>        this.prepareRefresh();
</span><span class='line'>        ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
</span><span class='line'>        this.prepareBeanFactory(beanFactory);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;    try {
</span><span class='line'>        this.postProcessBeanFactory(beanFactory);
</span><span class='line'>        this.invokeBeanFactoryPostProcessors(beanFactory);
</span><span class='line'>        this.registerBeanPostProcessors(beanFactory);
</span><span class='line'>        this.initMessageSource();
</span><span class='line'>        this.initApplicationEventMulticaster();
</span><span class='line'>        this.onRefresh();
</span><span class='line'>        this.registerListeners();
</span><span class='line'>        this.finishBeanFactoryInitialization(beanFactory);
</span><span class='line'>        this.finishRefresh();
</span><span class='line'>    } catch (BeansException var9) {
</span><span class='line'>        if(this.logger.isWarnEnabled()) {
</span><span class='line'>            this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        this.destroyBeans();
</span><span class='line'>        this.cancelRefresh(var9);
</span><span class='line'>        throw var9;
</span><span class='line'>    } finally {
</span><span class='line'>        this.resetCommonCaches();
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;}</span></code></pre></td></tr></table></div></figure></p>

<p>容器创建完成之后
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/&lt;em&gt;*
</span><span class='line'> * Called after the context has been refreshed.
</span><span class='line'> * @param context the application context
</span><span class='line'> * @param args the application arguments
</span><span class='line'> &lt;/em&gt;/
</span><span class='line'>protected void afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args) {
</span><span class='line'>   callRunners(context, args);
</span><span class='line'>}&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;private void callRunners(ApplicationContext context, ApplicationArguments args) {
</span><span class='line'>   List&lt;Object&gt; runners = new ArrayList&lt;Object&gt;();
</span><span class='line'>   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
</span><span class='line'>   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
</span><span class='line'>   // 对runners进行排序
</span><span class='line'>   AnnotationAwareOrderComparator.sort(runners);&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   for (Object runner : new LinkedHashSet&lt;Object&gt;(runners)) {
</span><span class='line'>      // 找出Spring容器中ApplicationRunner接口的实现类
</span><span class='line'>      if (runner instanceof ApplicationRunner) {
</span><span class='line'>         callRunner((ApplicationRunner) runner, args);
</span><span class='line'>      }
</span><span class='line'>      // 找出Spring容器中CommandLineRunner接口的实现类
</span><span class='line'>      if (runner instanceof CommandLineRunner) {
</span><span class='line'>         callRunner((CommandLineRunner) runner, args);
</span><span class='line'>      }
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
这样run方法执行完成之后。Spring容器也已经初始化完成，各种监听器和初始化器也做了相应的工作。</p>

<h2>配置自动导入</h2>

<pre><code>@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class&lt;?&gt;[] exclude() default {};

    String[] excludeName() default {};
}
</code></pre>

<p>主要看EnableAutoConfigurationImportSelector这个类，这个类会导入spring boot中的一个配置文件，方法如下：
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
<span class='line-number'>137</span>
<span class='line-number'>138</span>
<span class='line-number'>139</span>
<span class='line-number'>140</span>
<span class='line-number'>141</span>
<span class='line-number'>142</span>
<span class='line-number'>143</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,
</span><span class='line'>            AnnotationAttributes attributes) {
</span><span class='line'>        List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(
</span><span class='line'>                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
</span><span class='line'>        Assert.notEmpty(configurations,
</span><span class='line'>                &ldquo;No auto configuration classes found in META-INF/spring.factories. If you &rdquo;
</span><span class='line'>                        + &ldquo;are using a custom packaging, make sure that file is correct.&rdquo;);
</span><span class='line'>        return configurations;
</span><span class='line'> }&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;这个方法会导入spring-boot-autoconfigure包下META-INF/spring.factories配置文件spring.factories
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>&gt;Spring Boot 内部提供了很多自动化配置的类，例如，
</span><span class='line'>RedisAutoConfiguration 、MongoRepositoriesAutoConfiguration 、ElasticsearchAutoConfiguration ，
</span><span class='line'>这些自动化配置的类会判断 classpath 中是否存在自己需要的那个类，如果存在则会自动配置相关的配置，否则就不会自动配置，
</span><span class='line'>因此，开发者在 Maven 的 pom 文件中添加相关依赖后，这些依赖就会下载很多 jar 包到 classpath 中，有了这些 lib 就会触发自动化配置，
</span><span class='line'>所以，我们就能很便捷地使用对于的模块功能了。
</span><span class='line'>
</span><span class='line'>我们看一下自动加载的配置
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Initializers&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;org.springframework.context.ApplicationContextInitializer=\
</span><span class='line'>org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Application Listeners&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;org.springframework.context.ApplicationListener=\
</span><span class='line'>org.springframework.boot.autoconfigure.BackgroundPreinitializer&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Auto Configure&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
</span><span class='line'>org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jms.hornetq.HornetQAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.velocity.VelocityAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\
</span><span class='line'>org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Template availability providers&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\
</span><span class='line'>org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\
</span><span class='line'>org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\
</span><span class='line'>org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\
</span><span class='line'>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\
</span><span class='line'>org.springframework.boot.autoconfigure.velocity.VelocityTemplateAvailabilityProvider,\
</span><span class='line'>org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider
</span><span class='line'>&lt;code&gt;
</span><span class='line'>我们来看如何自动加载MongoAutoConfiguration
</span><span class='line'>&lt;/code&gt;
</span><span class='line'>@Configuration
</span><span class='line'>@ConditionalOnClass(MongoClient.class)
</span><span class='line'>@EnableConfigurationProperties(MongoProperties.class)
</span><span class='line'>@ConditionalOnMissingBean(type = &ldquo;org.springframework.data.mongodb.MongoDbFactory&rdquo;)
</span><span class='line'>public class MongoAutoConfiguration {&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   private final MongoProperties properties;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   private final MongoClientOptions options;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   private final Environment environment;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   private MongoClient mongo;
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure>
@ConditionalOnClass(MongoClient.class)
当我们的Jar依赖也就是有我们的环境中存在MongoClient.class,才会创建这个Bean；
其中ConditionalOnClass中依赖@Conditional(OnClassCondition.class)条件，判断是否加载。</p>

<h3>参考</h3>

<p><a href="http://www.imooc.com/article/15432">Spring Boot起步依赖源码分析</a><br/>
<a href="https://fangjian0423.github.io/2017/04/30/springboot-startup-analysis/">SpringBoot源码分析之SpringBoot的启动过程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpringBoot配置读取与加载的几种方式]]></title>
    <link href="http://lvzwq.github.io/blog/2017/07/01/springbootyu-jia-zai/"/>
    <updated>2017-07-01T23:14:32+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/07/01/springbootyu-jia-zai</id>
    <content type="html"><![CDATA[<blockquote><p>SpringBoot 简化了配置，将原来大量使用xml的配置使用Spring config的方式来是实现，这种方式看上去比xml更加简洁，更好理解。</p></blockquote>

<!-- more -->


<h3>SpringBoot 配置读取</h3>

<p>SpringBoot应用默认读取的应用配置是在application.properties或者application.yml文件中</p>

<pre><code>mq.consumer.topic=binlog.unionbusiness.UnionCommodity
mq.consumer.groupId=ad.cps.commission
mq.consumer.address=mq.keeper.service.xxx.org
mq.consumer.batchSize=20
mq.consumer.timeOut=2000

# mq Consumer 
mq.asyn.topic=binlog.unionbusiness.UnionAsynEffectOps
mq.asyn.groupId=unionads.cps.asyneffect
mq.asyn.address=mq.keeper.service.xxx.org
mq.asyn.batchSize=10
mq.asyn.timeOut=2000

# mq Producer
mq.producer.topic=ad.cpscommission.tradeitemid
mq.producer.groupId=ad.cps.commission
mq.producer.address=mq.keeper.service.xxx.org
</code></pre>

<p>读取的方式有很多种，第一种通过直接通过<code>@ConfigurationProperties</code>注解来读取配置</p>

<pre><code class="java">@Slf4j
@Data
@ConfigurationProperties(prefix = "mq.producer")
@Component
public class CorgiProducer implements InitializingBean, DisposableBean{

    private String topic;
    private String groupId;
    private String address;

    private static Producer producer;

...
}
</code></pre>

<p>另外一种，通过SpringMVC中<code>@Value("${xxx}")</code>注解的方式来获取属性文件中的值
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Data</span>
</span><span class='line'><span class="nd">@Component</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Config</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nd">@Value</span><span class="o">(</span><span class="s">&quot;${mq.consumer.groupId}&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">private</span> <span class="n">String</span> <span class="n">groupId</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Value</span><span class="o">(</span><span class="s">&quot;${mq.consumer.topic}&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">private</span> <span class="n">String</span> <span class="n">topic</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Value</span><span class="o">(</span><span class="s">&quot;${mq.consumer.address}&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">private</span> <span class="n">String</span> <span class="n">address</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Value</span><span class="o">(</span><span class="s">&quot;${mq.consumer.batchSize}&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">int</span> <span class="n">batchSize</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Value</span><span class="o">(</span><span class="s">&quot;${mq.consumer.timeOut}&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">long</span> <span class="n">timeOut</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&amp;</span><span class="n">hellip</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>通过@Bean结合@ConfigurationProperties的方式可以配置相同类的2个不同实例，如配置2个数据源。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">defaultConfig</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'><span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">mq</span><span class="o">.</span><span class="na">consumer</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'><span class="kd">public</span> <span class="n">CorgiConfig</span> <span class="nf">defaultCorgiConfig</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">CorgiConfig</span><span class="o">();</span>
</span><span class='line'><span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nd">@Bean</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">asynConfig</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'><span class="nd">@ConfigurationProperties</span><span class="o">(</span><span class="n">prefix</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">mq</span><span class="o">.</span><span class="na">asyn</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'><span class="kd">public</span> <span class="n">CorgiConfig</span> <span class="nf">asynCorgiConfig</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">CorgiConfig</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP学习]]></title>
    <link href="http://lvzwq.github.io/blog/2017/06/15/spring-aopxue-xi/"/>
    <updated>2017-06-15T19:49:18+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/06/15/spring-aopxue-xi</id>
    <content type="html"><![CDATA[<h3>AOP概念</h3>

<p>AOP概念和术语不是Spring独有的，AOP术语并不是直观感受的，而是一种抽象概念。</p>

<!-- more -->


<blockquote><p>切面Aspect: 跨越多个类的模块化的关系。事务管理就是其中一个典型的应用。
连接点Join Point： 程序运行中的一个点，比如调用方法和处理异常，在Spring AOP中，通常指代方法调用。
通知Advice: 在一个特殊的Joint Point被Aspect执行的动作。不同的类型的Advice有"around,&ldquo; "before&rdquo; 和 &ldquo;after&rdquo; 类型。
切入点Pointcut: 通知定义了切面要发生的“故事”和时间，那么切入点就定义了“故事”发生的地点，例如某个类或方法的名称，spring中允许我们方便的用正则表达式来指定</p></blockquote>

<p>Spring AOP是用纯Java实现的，不需要特殊的编译过程，并且不需要控制Classloader的层级关系，并且可以用在Servlet容器中和应用服务器中。
Spring AOP目前只支持方法级别的执行Joint Point(在Spring Bean中方法执行的通知Advice)。</p>

<h4>AOP代理</h4>

<p>Spring AOP代理默认使用标准SDK的动态代理，这允许代理任意接口interface。Spring AOP也可以使用CGLIB代理，这是代理类而不是代理接口interface,如果一个类没有实现一个接口默认是使用CGLIB代理的。</p>

<h4>@AspectJ</h4>

<p>需要手动开启@AspectJ支持，可以在Java配置中添加@Configuration上添加@EnableAspectJAutoProxy注解。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Configuration</span>
</span><span class='line'><span class="nd">@EnableAspectJAutoProxy</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">或者在xml配置中开启</span><span class="nd">@AspectJ</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">xml</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="nl">aop:</span><span class="n">aspectj</span><span class="o">-</span><span class="n">autoproxy</span><span class="o">/&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<ul>
<li><p>声明一个Aspect
开启了@AspectJ支持，任何Spring bean使用了@Aspect注解都将被Spring检测并配置成Spring AOP。</p></li>
<li><p>声明一个切入点Pointcut
使用@Pointcut注解的切入点表达式，并且注解的方法必须是含void返回值的方法。
<code>
@Pointcut("execution(* transfer(..))")  // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature
</code></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆内存最佳实践]]></title>
    <link href="http://lvzwq.github.io/blog/2017/06/08/dui-nei-cun-zui-jia-shi-jian/"/>
    <updated>2017-06-08T01:05:38+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/06/08/dui-nei-cun-zui-jia-shi-jian</id>
    <content type="html"><![CDATA[<!-- more -->


<h2>堆分析</h2>

<h3>采用堆直方图分析堆内存使用</h3>

<p>利用堆直方图，我们可以快速看到应用内的对象数目，同时不需要进行完整的堆转储。堆直方图获取方式<code>jcmd PID GC.class_histogram</code></p>

<pre><code class="sh">$ jcmd 16685 GC.class_histogram | more
16685:

 num     #instances         #bytes  class name
----------------------------------------------
   1:       3382715      310396224  [C
   2:       3293714       79049136  java.lang.String
   3:       2364000       75648000  java.util.HashMap$Node
   4:         14080       54832544  [I
   5:         95607       23472416  [B
   6:        159142       22423488  [Ljava.util.HashMap$Node;
   7:         53314       13002496  [Ljava.lang.Object;
   8:        524288       12582912  com.mogujie.union.cpmbilling.common.disruptor.CpmLogEvent
   9:        472423       11338152  java.util.concurrent.atomic.AtomicLong
  10:        164987        7919376  java.util.HashMap
  11:        142903        4572896  com.mogujie.union.cpmbilling.common.kafka.consumer.MessageInfo
  12:        161610        3878640  java.lang.Long
  13:        131572        3157728  com.mogujie.union.cpmbilling.common.kafka.producer.KafkaLogEntity
  14:        169888        2718208  java.lang.Integer
......
</code></pre>

<p>在接近顶端的地方，字符数组(<code>[C</code>)和<code>String</code>对象很常见，因为他们是最常创建的Java对象。字节数组(<code>[B</code>)和Object数组同样很常见。该命令不会强制执行Full GC，但是<code>GC.class_histogram</code>中的输出仅包含活跃对象。</p>

<p>运行下面的命令也会得到同样的结果
<code>sh
jmap -histo PID
</code>
<code>jmap</code>的输出中包含会被回收的对象(死对象)。如果在获取直方图之前强制执行一次Full GC，可以使用下面命令
<code>sh
jmap -histo:live PID
</code>
直方图擅长识别有分配了一两个特定类的过多实例而引发的问题，但是要进行深度的分析，就需要应用到堆转储。</p>

<h3>堆转储</h3>

<p>生成堆转储文件的方式
<code>sh
jcmd PID GC.heap_dump /path/to/save/heap_dump.hprof
</code>
或者
<code>sh
jmap -dump:live,file=/path/to/save/heap_dump.hprof PID
</code>
在jmap中包含live选项，这会在生成堆转储之前强制执行一次Full GC; jcmd默认就会这样做。如果你想包含其他对象(死对象)，可以在jcmd命令后面加上-all选项。</p>

<p>生成的heap_dump.hprof文件我们可以使用下面一些工具打开，常见的有:<br/>
<code>jhat</code>: 这是最原始的堆分析工具，它会读取堆转储文件，并运行一个小型的http服务器，可以在网页上查看堆转储的信息。</p>

<p>VisualVM 以及 mat等开源原件</p>

<p>对堆的第一遍分析通常涉及保留内存。一个对象的保留内存，是指回收该对象可以释放出的内存量。</p>

<h4>浅对象大小、保留对象大小及深对象大小</h4>

<blockquote><p>对于内存分析，还有其他两个很有用的术语: 浅(shallow)和深(deep)。一个对象的浅大小，值的是该对象本身的大小。如果该对象包含一个指向另一个对象的引用，4字节或8字节的引用会计算在内，但是目标对象的大小不会包含进来。</p>

<p>深大小则包含哪些对象的大小。深大小与保留大小的区别在于那些存在共享的对象。在深大小包括那些共享的内存空间，而保留大小则不包含。</p></blockquote>

<h3>内存溢出错误</h3>

<ul>
<li>JVM没有原生内存可用</li>
<li>永久代(在Java 7和更早的版本中) 或元空间(在Java 8)内存不足。</li>
<li>Java堆本身空间不足 - 对于给定的堆空间而言，应用中活跃对象太多</li>
<li>JVM执行GC耗时太多</li>
</ul>


<p>自动堆转储
OutOfMemoryError是不可预料的，我们很难确定应该何时获得堆转储。有几个JVM参数可以帮助我们获取</p>

<p>-XX:+HeapDumpOnOutOfMemoryError
该标志默认为false，打开该标志，JVM会在抛出OutOfMemoryError时创建堆转储。</p>

<p>-XX:HeapDumpPath=<path>
该标志执行堆转储存储路径。默认会生成java_pid.hprof文件</p>

<p>-XX:+HeapDumpAfterFullGC
这会在运行一次Full GC后生成一个堆转储文件</p>

<p>-XX:+HeapDumpBeforeFullGC
这回在运行一次Full GC之前生成一个堆转储文件</p>

<h3>减少内存使用</h3>

<h4>减少对象大小</h4>

<p>减少对象大小的大小有2种方式：减少实例变量的个数(效果很明显),或者减小实例变量的大小。</p>
]]></content>
  </entry>
  
</feed>
