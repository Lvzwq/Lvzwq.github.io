<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 闲散记事]]></title>
  <link href="http://lvzwq.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://lvzwq.github.io/"/>
  <updated>2017-06-01T01:24:06+08:00</updated>
  <id>http://lvzwq.github.io/</id>
  <author>
    <name><![CDATA[Lvzwq]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java性能优化一线程DUMP]]></title>
    <link href="http://lvzwq.github.io/blog/2017/05/27/javaxing-neng-you-hua-1/"/>
    <updated>2017-05-27T09:43:06+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/05/27/javaxing-neng-you-hua-1</id>
    <content type="html"><![CDATA[<p>参考: <a href="%E4%B8%89%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA%20Java%20Thread%20Dump%20%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90">三个实例演示 Java Thread Dump 日志分析</a></p>

<!-- more -->


<h3>Java程序线程Thread Dump分析</h3>

<p>通过<code>jstack -l PID</code>可以实时查看当前程序的线程dump</p>

<pre><code>"corgi-consumer-workers-ad.unionbusiness.unionalarm-7-1" #188 prio=5 os_prio=0 tid=0x00007f9e6006b000 nid=0x6297 waiting for monitor entry [0x00007f9dd2cb5000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.mogujie.union.adexchange.biz.process.DefaultMessageHandler.assembleAdResult(DefaultMessageHandler.java:116)
        - waiting to lock &lt;0x00000006c3bb2440&gt; (a java.lang.Object)
        at com.mogujie.union.adexchange.biz.process.DefaultMessageHandler.handle(DefaultMessageHandler.java:79)
        at com.mogujie.union.adexchange.common.corgi.CorgiConsumeInitializer.lambda$newListener$0(CorgiConsumeInitializer.java:32)
        at com.mogujie.union.adexchange.common.corgi.CorgiConsumeInitializer$$Lambda$9/799107722.onReceived(Unknown Source)
        at com.mogujie.corgi.client.consumer.consume.AbstractParallelWorkerGroup.consume0(AbstractParallelWorkerGroup.java:92)
        at com.mogujie.corgi.client.consumer.consume.AbstractParallelWorkerGroup.consume(AbstractParallelWorkerGroup.java:145)
        at com.mogujie.corgi.client.consumer.consume.SingleParallelWorkerGroup$1.run(SingleParallelWorkerGroup.java:73)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)

   Locked ownable synchronizers:
        - &lt;0x00000006c3b92898&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)
</code></pre>

<p>线程状态有
<code>jstack  -l PID</code> 查看java程序线程情况<br/>
•  死锁，Deadlock（重点关注） <br/>
•  等待资源，Waiting on condition（重点关注） <br/>
•  等待获取监视器，Waiting on monitor entry（重点关注） <br/>
•  阻塞，Blocked（重点关注） <br/>
•  执行中，Runnable <br/>
•  暂停，Suspended <br/>
•  对象等待中，Object.wait() 或 TIMED_WAITING <br/>
•  停止，Parked</p>

<ul>
<li>我们可以看到线程处于<code>Blocked</code>阻塞状态。说明线程等待资源超时！</li>
<li><code>waiting to lock &lt;0x00000006c3bb2440&gt;</code>指线程等待给<code>0x00000006c3bb2440</code>这个地址上锁。在线程dump文件中我们可以搜索到很多线程在等待给这个地址上锁，所以找到谁获得了这个锁，就可以找到问题的根源。</li>
<li><code>waiting for monitor entry [0x00007f9dd2cb5000]</code> 指线程通过同步块<code>synchronized(obj){...}</code>申请进入了临界区，从而进入了等待的<code>Entry Set</code>队列。</li>
<li>第一行中 <code>corgi-consumer-workers-ad.unionbusiness.unionalarm-7-1</code>是线程名(Thread Name); <code>prio</code>是线程优先级，<code>tid</code>是<code>Java Thread id</code>, <code>nid</code>是<code>native</code>线程<code>id</code>。</li>
</ul>


<h4>线DUMP中的注意事项</h4>

<p>1、不同的Java虚拟机的线程dump的内容是不一样的，JVM版本版本不同，dump信息也略有差异。<br/>
2、在实际运行中，一次dump可能只表示当时时刻的情况，还无法确认问题，所以建议多次dump信息，如果多次的结果指向同一个地方，则可以确定问题的原因。<br/>
3、线程状态中，Deadlock: 死锁线程，一般指多个线程调用，进入相互资源调用，导致一直等待无法释放的情况。<br/>
4、<code>waiting on condition</code>: 等待资源，或等待某个条件的发生。<br/>
5、<code>waiting for monitor entry</code>和 <code>Object.wait()</code>: <code>Monitor</code>是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。
从下图1中可以看出，每个 <code>Monitor</code>在某个时刻，只能被一个线程拥有，该线程就是 &ldquo;Active Thread"，而其它线程都是 "Waiting Thread"，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 "Waiting for monitor entry"，而在 "Wait Set"中等待的线程状态是 "in Object.wait()"。</p>

<p><img src="http://7xig7d.com1.z0.glb.clouddn.com/java_monitor.png" alt="http://7xig7d.com1.z0.glb.clouddn.com/java_monitor.png" /></p>

<h4>CPU飙高问题排查</h4>

<ul>
<li>通过top命令查看CPU占用较高的进程ID</li>
<li>通过jstack命令将java的线程栈输出，保留现场<code>jstack -l 30142 &gt; 30142.stack</code></li>
<li>通过<code>top -H -p PID</code>命令输出占用cpu过高的线程 找到占用cpu过高的PID</li>
<li>使用printf 命令将30450转换成16进制。<code>printf "%x\n" 18430</code></li>
<li>打开之前保存的stack文件，找到线程地址为<code>0x76f2</code>的输出，即为出问题的线程</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java 对字符串转为可执行代码]]></title>
    <link href="http://lvzwq.github.io/blog/2017/04/25/java-dui-zi-fu-chuan-zhuan-wei-ke-zhi-xing-dai-ma/"/>
    <updated>2017-04-25T00:54:14+08:00</updated>
    <id>http://lvzwq.github.io/blog/2017/04/25/java-dui-zi-fu-chuan-zhuan-wei-ke-zhi-xing-dai-ma</id>
    <content type="html"><![CDATA[<!--more-->


<h2>方法一</h2>

<p>参考: <a href="http://wiselyman.iteye.com/blog/1677444">java实现字符串转换成可执行代码</a></p>

<p>使用commons的jexl包</p>

<pre><code>    &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-jexl&lt;/artifactId&gt;
            &lt;version&gt;2.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>

<p>代码示例</p>

<pre><code>    Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();  
    map.put("testService",testService);  
    map.put("person",person);  
    String expression="testService.save(person)";  

     JexlEngine jexl=new JexlEngine();  
     Expression e = jexl.createExpression(expression);  
     JexlContext jc = new MapContext();  
     for(String key:map.keySet()){  
           jc.set(key, map.get(key));  
     }  
     Object o = e.evaluate(jc);
</code></pre>

<h2>方式二</h2>

<p>参考:<a href="http://blog.csdn.net/w1014074794/article/details/45968559">java执行字符串数学表达式 ScriptEngine</a></p>

<p>使用Java自带的jdk, <code>javax.script.ScriptEngine</code></p>

<pre><code>        String str = "3&amp;&amp;2&amp;&amp;1";
        ScriptEngineManager factory = new ScriptEngineManager();
        ScriptEngine engine = factory.getEngineByName("JavaScript");
        str = str.replace("2", "true");
        str = str.replace("3", "true");
        str = str.replace("1", "false");
        Object o = null;
        try {
            o = engine.eval(str);
        } catch (ScriptException e) {
            e.printStackTrace();
        }
</code></pre>
]]></content>
  </entry>
  
</feed>
